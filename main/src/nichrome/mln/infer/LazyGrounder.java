package nichrome.mln.infer;

import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

import org.apache.commons.lang3.Pair;

import nichrome.mln.Atom;
import nichrome.mln.Clause;
import nichrome.mln.GClause;
import nichrome.mln.MarkovLogicNetwork;
import nichrome.mln.Predicate;
import nichrome.mln.Term;
import nichrome.mln.Clause.ClauseInstance;
import nichrome.mln.db.RDB;
import nichrome.mln.util.Config;
import nichrome.mln.util.Parallel;
import nichrome.mln.util.Timer;
import nichrome.mln.util.UIMan;

public class LazyGrounder {
	/**
	 * The clauses produced by lazy grounding.
	 */
	private Set<GClause> groundedClauses = new HashSet<GClause>();
	private Set<GClause> blockedClauses = new HashSet<GClause>();
	private Set<GClause> violatedClauses;
	private Set<GClause> lastViolatedClauses;
	/**
	 * The grounded clauses generated by hard evidence.
	 */
	private volatile boolean hasHardClauseViolated;
	private RDB db;
	private MarkovLogicNetwork mln;
	private Set<Integer> trueHardEvidence = new HashSet<Integer>();
	private Set<Integer> falseHardEvidence = new HashSet<Integer>();
	private Map<Integer, Double> trueSoftEvidence =
		new HashMap<Integer, Double>();
	private Map<Integer, Double> falseSoftEvidence =
		new HashMap<Integer, Double>();
	private Set<Integer> lastLoadedAtoms = new HashSet<Integer>();

	public LazyGrounder(RDB db, MarkovLogicNetwork mln) {
		this.db = db;
		this.mln = mln;
		for (Predicate p : mln.getAllPred()) {
			for (Atom at : p.getHardEvidences()) {
				int atId = mln.getAtomID(at.base());
				if (at.truth) {
					this.trueHardEvidence.add(atId);
				} else {
					this.falseHardEvidence.add(atId);
				}
			}
			for (Atom at : p.getSoftEvidences()) {
				if (at.prior > 0) {
					this.trueSoftEvidence.put(mln.getAtomID(at.base()),
						at.prior.doubleValue());
				} else if (at.prior < 0) {
					this.falseSoftEvidence.put(mln.getAtomID(at.base()),
						0 - at.prior.doubleValue());
				}
			}
		}
	}

	public boolean hasHardClauseViolated() {
		return this.hasHardClauseViolated;
	}

	public Set<GClause> getGroundedClauses() {
		return Collections.unmodifiableSet(this.groundedClauses);
	}

	public Set<GClause> getViolatedClauses() {
		return Collections.unmodifiableSet(this.violatedClauses);
	}

	public Set<GClause> getlastViolatedClauses() {
		return Collections.unmodifiableSet(this.lastViolatedClauses);
	}

	/**
	 * Use the database to ground violated clauses (hard+soft).
	 *
	 * @param atoms
	 */
	public void ground(Set<Integer> atoms) {
		String groundTimer = "ground";
		Clause mostExpensiveClause = null;
		String mostExpensiveQuery = null;
		double maxExecutionTime = -1.0;
		String singleSqlTimer = "single sql";
		try {
			this.lastViolatedClauses = this.violatedClauses;
			this.violatedClauses = new HashSet<GClause>();
			this.hasHardClauseViolated = false;
			if (!Config.useCAV) {
				this.groundEvidence(atoms);
			} else {
				this.addEvidence(atoms);
			}
			this.loadDB(atoms);
			Timer.start(groundTimer);
			for (Clause c : this.mln.getAllNormalizedClauses()) {
				Set<GClause> currentGCs = new HashSet<GClause>();
				if (c.isTemplate()) {
					for (ClauseInstance ci : c.instances) {

						if (Config.verbose_level >= 2) {
							Timer.start(singleSqlTimer);
						}

						ResultSet result;
						if (ci.isPositiveClause()) {
							result = ci.checkVioSt.executeQuery();
						} else {
							result = ci.satSt.executeQuery();
						}

						if (Config.verbose_level >= 2) {
							double elapsedTime =
								Timer.elapsedSeconds(singleSqlTimer);
							if (elapsedTime > maxExecutionTime) {
								maxExecutionTime = elapsedTime;
								mostExpensiveClause = c;
								mostExpensiveQuery = ci.checkVioSql;
							}
						}

						boolean isResultEmpty = true;
						while (result.next()) {
							GClause gc = new GClause(c, ci);
							gc.parse(result, this.mln);
							currentGCs.add(gc);
							isResultEmpty = false;
						}
						// each instance clause might have different weights
						if (ci.isHardClause() && !isResultEmpty) {
							System.out.println("violated hard clause: " + ci);
							this.hasHardClauseViolated = true;
						}
					}
				} else {
					if (Config.verbose_level >= 2) {
						Timer.start(singleSqlTimer);
					}

					ResultSet result;
					if (c.isPositiveClause()) {
						result = c.checkVioSt.executeQuery();
					} else {
						result = c.satSt.executeQuery();
					}

					if (Config.verbose_level >= 2) {
						double elapsedTime =
							Timer.elapsedSeconds(singleSqlTimer);
						if (elapsedTime > maxExecutionTime) {
							maxExecutionTime = elapsedTime;
							mostExpensiveClause = c;
							mostExpensiveQuery = c.checkVioSql;
						}
					}

					while (result.next()) {
						GClause gc = new GClause(c, null);
						gc.parse(result, this.mln);
						currentGCs.add(gc);
					}
					if (c.isHardClause() && currentGCs.size() != 0) {
						System.out.println("violated hard clause: " + c);
						this.hasHardClauseViolated = true;
					}
				}
				this.addGroundClauses(currentGCs);
			}
			// Account for reverted constraints. 
			for (GClause gc : this.getGroundedClauses()) {
				if (gc.c == null && gc.ci == null && gc.lits.length > 1) {
					boolean isViolated = gc.isPositiveClause() ? gc.isViolated(atoms) : !gc.isViolated(atoms);
					if (isViolated && Config.log_vio_clauses) {
						this.violatedClauses.add(gc);
					}
				}
			}
			if (Config.verbose_level >= 1) {
				Timer.printElapsed(groundTimer);
			}
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
		if (Config.verbose_level >= 2) {
			UIMan.println("The most expensive clause: " + mostExpensiveClause);
			UIMan.println("Its query(" + maxExecutionTime + "s): "
				+ mostExpensiveQuery);
			UIMan.println("Its execution plan:");
			this.explain(mostExpensiveQuery);
		}
	}

	public void groundConcurrently(Set<Integer> atoms) {
		String groundTimer = "ground";
		this.hasHardClauseViolated = false;
		this.lastViolatedClauses = this.violatedClauses;
		this.violatedClauses = new HashSet<GClause>();
		this.groundEvidence(atoms);
		this.loadDB(atoms);
		Timer.start(groundTimer);
		Parallel.For(this.mln.getAllNormalizedClauses(), new QueryClause());
		if (Config.verbose_level >= 1) {
			Timer.printElapsed(groundTimer);
		}

	}

	private class QueryClause implements Parallel.Operation<Clause> {

		@Override
		public void perform(Clause c) {
			Set<GClause> currentGCs = new HashSet<GClause>();
			try {
				if (c.isTemplate()) {
					for (ClauseInstance ci : c.instances) {
						ResultSet result;
						if (ci.isPositiveClause()) {
							result = ci.checkVioSt.executeQuery();
						} else {
							result = ci.satSt.executeQuery();
						}
						while (result.next()) {
							GClause gc = new GClause(ci.parent, null);
							gc.parse(result, LazyGrounder.this.mln);
							currentGCs.add(gc);
						}
					}
				} else {
					ResultSet result;
					if (c.isPositiveClause()) {
						result = c.checkVioSt.executeQuery();
					} else {
						result = c.satSt.executeQuery();
					}
					while (result.next()) {
						GClause gc = new GClause(c, null);
						gc.parse(result, LazyGrounder.this.mln);
						currentGCs.add(gc);
					}
				}
			} catch (SQLException e) {
				e.printStackTrace();
				throw new RuntimeException(e);
			}
			if (c.isHardClause() && currentGCs.size() != 0) {
				LazyGrounder.this.hasHardClauseViolated = true;
			}
			synchronized (LazyGrounder.this.groundedClauses) {
				LazyGrounder.this.addGroundClauses(currentGCs);
			}
		}
	}

	private class QueryClauseInstance implements
		Parallel.Operation<ClauseInstance> {

		@Override
		public void perform(ClauseInstance ci) {
			Set<GClause> currentGCs = new HashSet<GClause>();
			try {
				ResultSet result;
				if (ci.isPositiveClause()) {
					result = ci.checkVioSt.executeQuery();
				} else {
					result = ci.satSt.executeQuery();
				}
				while (result.next()) {
					GClause gc = new GClause(ci.parent, null);
					gc.parse(result, LazyGrounder.this.mln);
					currentGCs.add(gc);
				}
			} catch (SQLException e) {
				throw new RuntimeException(e);
			}
			if (ci.isHardClause() && currentGCs.size() != 0) {
				LazyGrounder.this.hasHardClauseViolated = true;
			}
			synchronized (LazyGrounder.this.groundedClauses) {
				LazyGrounder.this.addGroundClauses(currentGCs);
			}
		}

	}
	
	public void blockSolutions(List<Set<Integer>> allSolutions) {
		String blockTimer = "Blocking solutions timer";
		Timer.start(blockTimer);
		
		for (Set<Integer> solution : allSolutions) {
			int[] currSolution = new int[mln.getNumAtoms()];
			int i = 0;
			for (Integer s : solution) {
				currSolution[i++] = -s; 
			}
			for (int j = 1; j <= mln.getNumAtoms(); ++j) {
				if (!solution.contains(j)) {
					currSolution[i++] = j; 
				}
			}
			GClause gc = new GClause(Config.hard_weight, currSolution);
			this.groundedClauses.add(gc);
			this.blockedClauses.add(gc);
		}
		
		if (Config.verbose_level >= 1) {
			Timer.printElapsed(blockTimer);
			UIMan.println("Number of blocked clauses: " + this.blockedClauses.size());
		}
	}
	
	public void clearBlockedSolutions() {
		this.groundedClauses.removeAll(this.blockedClauses);
		this.blockedClauses.clear();
	}
 
	private void groundEvidence(Set<Integer> atoms) {
		String eviTimer = "Evidence grounding timer";
		Timer.start(eviTimer);
		// Check hard evidences
		Set<Integer> theCopy = new HashSet<Integer>(this.trueHardEvidence);
		theCopy.removeAll(atoms);
		if (theCopy.size() != 0) {
			this.hasHardClauseViolated = true;
			for (int vhe : theCopy) {
				GClause gc = new GClause(Config.hard_weight, vhe);
				this.addGroundClause(gc);
			}
		}

		Set<Integer> fheCopy = new HashSet<Integer>(this.falseHardEvidence);
		fheCopy.retainAll(atoms);
		if (fheCopy.size() != 0) {
			this.hasHardClauseViolated = true;
			for (int vhe : fheCopy) {
				GClause gc = new GClause(Config.hard_weight, -vhe);
				this.addGroundClause(gc);
			}
		}
		// Check closed-world predicate
		for (int atId : atoms) {
			Atom atom = this.mln.getAtom(atId);
			Predicate p = atom.pred;
			if (p.isClosedWorld() && !this.trueHardEvidence.contains(atId)
				&& !this.trueSoftEvidence.containsKey(atId)
				&& !this.falseSoftEvidence.containsKey(atId)) {
				this.hasHardClauseViolated = true;
				GClause gc = new GClause(Config.hard_weight, -atId);
				this.addGroundClause(gc);
			}
		}

		// Check soft evidences
		for (Map.Entry<Integer, Double> eviEntry : this.trueSoftEvidence
			.entrySet()) {
			int atId = eviEntry.getKey();
			if (!atoms.contains(atId)) {
				GClause gc = new GClause(eviEntry.getValue(), atId);
				this.addGroundClause(gc);
			}
		}

		for (Map.Entry<Integer, Double> eviEntry : this.falseSoftEvidence
			.entrySet()) {
			int atId = eviEntry.getKey();
			if (atoms.contains(atId)) {
				GClause gc = new GClause(eviEntry.getValue(), -atId);
				this.addGroundClause(gc);
			}
		}

		if (Config.verbose_level >= 1) {
			Timer.printElapsed(eviTimer);
		}
	}
	
	// For CAV'13
	private void addEvidence(Set<Integer> atoms) {
		String eviTimer = "Evidence adding timer";
		Timer.start(eviTimer);
		atoms.addAll(this.trueHardEvidence);
	
		//TODO: Verify
		// atoms.addAll(this.trueSoftEvidence);

		if (Config.verbose_level >= 1) {
			Timer.printElapsed(eviTimer);
		}
	}

	private void explain(String sql) {
		if (Config.verbose_level >= 2) {
			UIMan.println("Execution plan for " + sql + ":");
			UIMan.println(this.db.explain(sql));
		}
	}

	/**
	 * Clear all the predicate tables. Use with care.
	 */
	public void resetDB() {
		String cleanTimer = "DB clean timer";
		Timer.start(cleanTimer);
		this.lastLoadedAtoms = null;
		for (Predicate p : this.mln.getAllPred()) {
			p.cleanTable();
		}
		if (Config.verbose_level >= 1) {
			Timer.printElapsed(cleanTimer);
		}
	}

	private void loadDB(Set<Integer> atoms) {
		String loadTimer = "DB loading timer";
		Timer.start(loadTimer);
		if (this.lastLoadedAtoms == null || this.lastLoadedAtoms.isEmpty()) {
			this.loadDBSimple(atoms);
			this.lastLoadedAtoms = atoms;
		} else {
			this.loadDBIncrement(atoms);
		}
		if (Config.verbose_level >= 1) {
			Timer.printElapsed(loadTimer);
		}
	}

	private void loadDBSimple(Set<Integer> atoms) {
		Map<Predicate, List<Atom>> atomToLoad =
			new HashMap<Predicate, List<Atom>>();
		for (int i : atoms) {
			Atom at = this.mln.getAtom(i);
			List<Atom> ats = atomToLoad.get(at.pred);
			if (ats == null) {
				ats = new ArrayList<Atom>();
				atomToLoad.put(at.pred, ats);
			}
			ats.add(at);
		}
		for (Predicate p : this.mln.getAllPred()) {
			p.cleanTable();
			List<Atom> ats = atomToLoad.get(p);
			if (ats != null) {
				p.loadTable(ats);
				// db.analyze(p.getRelName());
			}
		}
		UIMan.verbose(2, "# of inserted rows: " + atoms.size());
		UIMan.verbose(2, "# of deleted rows: " + 0);
	}

	private void loadDBIncrement(Set<Integer> atoms) {
		this.db.setAutoCommit(false);
		Set<Integer> atomsToInsert = new HashSet<Integer>(atoms);
		atomsToInsert.removeAll(this.lastLoadedAtoms);
		Set<Integer> atomsToDelete = new HashSet<Integer>(this.lastLoadedAtoms);
		atomsToDelete.removeAll(atoms);
		for (int at : atomsToDelete) {
			Atom atom = this.mln.getAtom(at);
			atom.pred.deleteAtom(atom);
		}
		for (int at : atomsToInsert) {
			Atom atom = this.mln.getAtom(at);
			atom.pred.insertAtom(atom);
		}
		this.db.commit();
		this.db.setAutoCommit(true);
		UIMan.verbose(2, "# of inserted rows: " + atomsToInsert.size());
		UIMan.verbose(2, "# of deleted rows: " + atomsToDelete.size());

		this.lastLoadedAtoms = atoms;
	}

	/**
	 * Evaluate a solution, return the objective function
	 *
	 * @param atoms
	 * @return
	 */
	public double evaluate(Set<Integer> atoms) {
		this.loadDB(atoms);
		return this.evaluateWithoutLoad(atoms);
	}

	/**
	 * Similar with evaluate(Set<integer>) except that it assumes that the atoms
	 * are already loaded. And we only evaluate soft constraints.
	 *
	 * @return
	 */
	public double evaluateWithoutLoad(Set<Integer> atoms) {
		String evalTimer = "evaluate";
		Timer.start(evalTimer);
		double ret = 0.0;
		// positive weights
		for (Integer i : atoms) {
			Double weight = this.trueSoftEvidence.get(i);
			if (weight != null) {
				ret += weight;
			}
		}
		// negative weights
		for (Map.Entry<Integer, Double> entry : this.falseSoftEvidence
			.entrySet()) {
			double weight = entry.getValue();
			if (!atoms.contains(entry.getKey())) {
				ret += weight;
			}
		}

		try {
			for (Clause c : this.mln.getAllNormalizedClauses()) {
				if (c.isHardClause()) {
					continue;
				}
				if (c.isTemplate()) {
					for (ClauseInstance ci : c.instances) {
						if (ci.isHardClause()) {
							continue;
						}
						// ResultSet result = ci.evalSt.executeQuery();
						// int evalCount = this.getCount(result);
						// this.explain(ci.revEvalSql);
						ResultSet result = ci.revEvalSt.executeQuery();
						int revCount = this.getCount(result);
						if (revCount < 0) {
							throw new RuntimeException(
								"Integer overflow: revCount " + revCount);
						}
						double evalCount = c.getFullyGroundSize() - revCount;
						if (evalCount < 0) {
							throw new RuntimeException(
								"Integer overflow: revCount " + revCount
									+ ", ground size: "
									+ c.getFullyGroundSize());
						}
						// This works for, both, positive and negative weights.
						ret += evalCount * ci.weight;
					}
				} else {
					// ResultSet result = c.evalSt.executeQuery();
					// int evalCount = this.getCount(result);
					// this.explain(c.revEvalSql);
					ResultSet result = c.revEvalSt.executeQuery();
					int revCount = this.getCount(result);
					if (revCount < 0) {
						throw new RuntimeException(
							"Integer overflow: revCount " + revCount);
					}
					double evalCount = c.getFullyGroundSize() - revCount;
					if (evalCount < 0) {
						throw new RuntimeException(
							"Integer overflow: revCount " + revCount
								+ ", ground size: " + c.getFullyGroundSize());
					}
					// This works for, both, positive and negative weights.
					ret += evalCount * c.getWeight();
				}
			}
			// Account for reverted constraints.
			for (GClause gc : this.getGroundedClauses()) {
				if (gc.c == null && gc.ci == null && gc.lits.length > 1) {
					if(!gc.isViolated(atoms)) {
						ret += gc.weight;
					}
				}
			}
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
		if (Config.verbose_level >= 1) {
			Timer.printElapsed(evalTimer);
		}
		return ret;
	}

	/**
	 * Evaluate a solution, return the weight of the
	 * violated constraints
	 *
	 * @param atoms
	 * @return
	 */
	public double evaluateCost(Set<Integer> atoms) {
		this.loadDB(atoms);
		return this.evaluateCostWithoutLoad(atoms);
	}

	/**
	 * Similar with evaluate(Set<integer>) except that it assumes that the atoms
	 * are already loaded. And we only evaluate soft constraints.
	 *
	 * @return
	 */
	public double evaluateCostWithoutLoad(Set<Integer> atoms) {
		String evalTimer = "cost";
		Timer.start(evalTimer);
		double ret = 0.0;
		// negative weights
		for (Integer i : atoms) {
			Double weight = this.falseSoftEvidence.get(i);
			if (weight != null) {
				ret += weight;
			}
		}
		// positive weights
		for (Map.Entry<Integer, Double> entry : this.trueSoftEvidence
			.entrySet()) {
			double weight = entry.getValue();
			if (!atoms.contains(entry.getKey())) {
				ret += weight;
			}
		}

		try {
			for (Clause c : this.mln.getAllNormalizedClauses()) {
				if (c.isHardClause()) {
					continue;
				}
				if (c.isTemplate()) {
					for (ClauseInstance ci : c.instances) {
						if (ci.isHardClause()) {
							continue;
						}
						// ResultSet result = ci.evalSt.executeQuery();
						// int evalCount = this.getCount(result);
						// this.explain(ci.revEvalSql);
						ResultSet result = ci.revEvalSt.executeQuery();
						int revCount = this.getCount(result);
						if (revCount < 0) {
							throw new RuntimeException(
								"Integer overflow: revCount " + revCount);
						}
						double evalCount = c.getFullyGroundSize() - revCount;
						if (evalCount < 0) {
							throw new RuntimeException(
								"Integer overflow: revCount " + revCount
									+ ", ground size: "
									+ c.getFullyGroundSize());
						}
						if (ci.isPositiveClause()) {
							ret += revCount * ci.weight;
						} else {
							ret += evalCount * (ci.weight * -1);
						}
					}
				} else {
					// ResultSet result = c.evalSt.executeQuery();
					// int evalCount = this.getCount(result);
					// this.explain(c.revEvalSql);
					ResultSet result = c.revEvalSt.executeQuery();
					int revCount = this.getCount(result);
					if (revCount < 0) {
						throw new RuntimeException(
							"Integer overflow: revCount " + revCount);
					}
					double evalCount = c.getFullyGroundSize() - revCount;
					if (evalCount < 0) {
						throw new RuntimeException(
							"Integer overflow: revCount " + revCount
								+ ", ground size: "
								+ c.getFullyGroundSize());
					}
					if (c.isPositiveClause()) {
						ret += revCount * c.getWeight();
					} else {
						ret += evalCount * (c.getWeight() * -1);
					}
				}
			}
			// Account for reverted constraints.
			for (GClause gc : this.getGroundedClauses()) {
				if (gc.c == null && gc.ci == null && gc.lits.length > 1) {
					if(gc.isViolated(atoms)) {
						ret += gc.weight;
					}
				}
			}
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
		if (Config.verbose_level >= 1) {
			Timer.printElapsed(evalTimer);
		}
		return ret;
	}
	
	private void addGroundClause(GClause gc) {
		this.groundedClauses.add(gc);
		if (Config.log_vio_clauses) {
			this.violatedClauses.add(gc);
		}
	}

	private void addGroundClauses(Collection<GClause> gcs) {
		this.groundedClauses.addAll(gcs);
		if (Config.log_vio_clauses) {
			this.violatedClauses.addAll(gcs);
		}
	}

	public int getCount(ResultSet rs) throws SQLException {
		rs.next();
		return rs.getInt("num");
	}

	/**
	 * Store all the grounded constraints to a file
	 *
	 * @param out
	 */
	public void storeGoundedConstraints(OutputStream out) {
		PrintWriter pw = new PrintWriter(out);
		for (GClause gc : this.groundedClauses) {
			pw.println(gc.toVerboseString(this.mln));
		}
		pw.flush();
		pw.close();
	}

	/**
	 * Example of accepted format: 1.0E7: NOT reachableCM(0,0), NOT
	 * MobjVarAsgnInst(0,25,24), RobjVarAsgnInst(0,25,24)
	 *
	 * @param in
	 */
	public void loadGroundedConstraints(InputStream in) {
		try {
			BufferedReader reader =
				new BufferedReader(new InputStreamReader(in));
			String line = null;
			while ((line = reader.readLine()) != null) {
				if(line.startsWith("//"))
					continue;
				String[] parts = line.split(": ");
				double weight;
				if (parts[0].equals("infi")) {
					weight = Config.hard_weight;
				} else {
					weight = Double.parseDouble(parts[0]);
				}
				String litStrs[] = parts[1].split(", ");
				int lits[] = new int[litStrs.length];
				for (int i = 0; i < litStrs.length; i++) {
					String litSegs[] = litStrs[i].split(" ");
					boolean isNeg = (litSegs.length > 1);
					String atomStr = litSegs[litSegs.length - 1];
					Atom at = this.mln.parseAtom(atomStr);
					int atId = this.mln.getAtomID(at);
					if(Config.fullyGround){
						Predicate p = at.pred;
						if (p.isClosedWorld() && !this.trueHardEvidence.contains(atId)
								&& !this.trueSoftEvidence.containsKey(atId)
								&& !this.falseSoftEvidence.containsKey(atId)) {
							GClause gc = new GClause(Config.hard_weight, -atId);
							this.groundedClauses.add(gc);
						}
					}
					if (isNeg) {
						atId = 0 - atId;
					}
					lits[i] = atId;
				}
				GClause gc = this.mln.matchGroundedClause(weight, lits);
				if (gc != null) {
					this.groundedClauses.add(gc);
				}
			}
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}
	
	/**
	 * Fully ground EDB and feedback initially 
	 */
	public void fullyGround(){
		//Add true edb
		for(int atId : this.trueHardEvidence){
			GClause gc = new GClause(Config.hard_weight, atId);
			this.groundedClauses.add(gc);
		}
		// Require feedback and fully grounded MLN rules to be
		// added in the warm start file
	}
	
	/**
	 * Example of accepted format: 1.0E7: NOT reachableCM(0,0), NOT
	 * MobjVarAsgnInst(0,25,24), RobjVarAsgnInst(0,25,24)
	 *
	 * @param in
	 */
	public void loadRevertedConstraints(InputStream in) {
		try {
			BufferedReader reader =
				new BufferedReader(new InputStreamReader(in));
			String line = null;
			while ((line = reader.readLine()) != null) {
				String[] parts = line.split(": ");
				double weight;
				if (parts[0].equals("infi")) {
					weight = Config.hard_weight;
				} else {
					weight = Double.parseDouble(parts[0]);
				}
				String litStrs[] = parts[1].split(", ");
				int lits[] = new int[litStrs.length];
				for (int i = 0; i < litStrs.length; i++) {
					String litSegs[] = litStrs[i].split(" ");
					boolean isNeg = (litSegs.length > 1);
					String atomStr = litSegs[litSegs.length - 1];
					Atom at = this.mln.parseAtom(atomStr);
					int atId = this.mln.getAtomID(at);
					if (isNeg) {
						atId = 0 - atId;
					}
					lits[i] = atId;
				}
				GClause gc = new GClause(weight, lits);
				this.groundedClauses.add(gc);
			}
		} catch (IOException e) {
			throw new RuntimeException(e);
		}
	}

	/**
	 * For each un-grounded clause in the MLN, find the number of grounded
	 * clauses violated and satisfied, in that order, by the given solution.
	 *
	 * @param atoms
	 * @return
	 */
	public HashMap<String, Pair<Double, Double>> countViolations(
		Set<Integer> atoms) {
		if(Config.count_vio_no_db)
			return this.countViolationsWithoutDB(atoms);
		this.loadDB(atoms);
		return this.countViolationsWithoutLoad();	
	}
	
	/*
	 * Counting violated clauses without querying the database
	 */
	public HashMap<String, Pair<Double, Double>> countViolationsWithoutDB(Set<Integer> sol) {
		String countTimer = "countNoDB";
		Timer.start(countTimer);
		HashMap<String, List<Double>> vioMap = new HashMap<String,List<Double>>();
		for(Clause c : mln.getAllNormalizedClauses()){
			if(c.isTemplate()){
				for(ClauseInstance ci : c.instances){
					List<Double> vioList = new ArrayList<Double>();
					vioList.add(0.0);
					vioList.add(c.getFullyGroundSize());
					vioMap.put(ci.getStrId(), vioList);
				}
			}else{
				List<Double> vioList = new ArrayList<Double>();
				vioList.add(0.0);
				vioList.add(c.getFullyGroundSize());
				vioMap.put(c.getStrId(), vioList);
			}
		}
		
		for(GClause gc : this.groundedClauses){
			if(gc.c == null) continue;
			if(!gc.isSatisfiedBy(sol)){
				Clause c = gc.c;
				String id = c.getStrId();
				if(c.isTemplate()){
					id = gc.ci.getStrId();
				}
				List<Double> vioPair = vioMap.get(id);
				if(vioPair == null){
					if(c.isPositiveClause()){
						vioPair = new ArrayList<Double>();
						vioPair.add(0.0);
						vioPair.add(c.getFullyGroundSize());
					}else{
						vioPair = new ArrayList<Double>();
						vioPair.add(c.getFullyGroundSize());
						vioPair.add(0.0);
					}
					vioMap.put(id, vioPair);
				}
				if(c.isPositiveClause()){
					Double left,right;
					left = vioPair.get(0);
					right = vioPair.get(1);
					left = left + 1;
					right = right - 1;
					vioPair.clear();
					vioPair.add(left);
					vioPair.add(right);
				}else{
					Double left,right;
					left = vioPair.get(0);
					right = vioPair.get(1);
					left = left - 1;
					right = right + 1;
					vioPair.clear();
					vioPair.add(left);
					vioPair.add(right);
				}
				
			}
		}
		HashMap<String, Pair<Double, Double>> clauseViolationMap =
				new HashMap<String, Pair<Double, Double>>();
		for(String id : vioMap.keySet()){
			List<Double> vioL = vioMap.get(id);
			Pair<Double,Double> vioPair = new Pair<Double,Double>(vioL.get(0),vioL.get(1));
			clauseViolationMap.put(id, vioPair);
		}
		if (Config.verbose_level >= 1) {
			Timer.printElapsed(countTimer);
		}
		return clauseViolationMap;
	}

	/**
	 * Similar with countViolations(Set<integer>) except that it assumes that
	 * the atoms are already loaded.
	 *
	 * @return
	 */
	public HashMap<String, Pair<Double, Double>> countViolationsWithoutLoad( ) {
		String countTimer = "count";
		Timer.start(countTimer);
		HashMap<String, Pair<Double, Double>> clauseViolationMap =
			new HashMap<String, Pair<Double, Double>>();
		try {
			for (Clause c : this.mln.getAllNormalizedClauses()) {
				if (c.isTemplate()) {
					for (ClauseInstance ci : c.instances) {
						// ResultSet result = ci.evalSt.executeQuery();
						// int evalCount = this.getCount(result);
						// this.explain(ci.revEvalSql);
						ResultSet result1 = ci.revEvalSt.executeQuery();
						double revCount = this.getCount(result1);
						if (revCount < 0) {
							throw new RuntimeException(
								"Integer overflow: revCount " + revCount);
						}
						//ResultSet result2 = ci.evalSt.executeQuery();
						//int evalCount = this.getCount(result2);
						double evalCount = 
							c.getFullyGroundSize() - revCount;
						if (evalCount < 0) {
							throw new RuntimeException(
								"Integer overflow: revCount " + revCount
									+ ", ground size: "
									+ c.getFullyGroundSize());
						}
						if (ci.isPositiveClause()) {
							clauseViolationMap.put(ci.getStrId(),
								new Pair<Double, Double>(revCount, evalCount));
						} else {
							clauseViolationMap.put(ci.getStrId(),
								new Pair<Double, Double>(evalCount, revCount));
						}
					}
				} else {
					// ResultSet result = c.evalSt.executeQuery();
					// int evalCount = this.getCount(result);
					// this.explain(c.revEvalSql);
					ResultSet result1 = c.revEvalSt.executeQuery();
					double revCount = this.getCount(result1);
					if (revCount < 0) {
						throw new RuntimeException(
							"Integer overflow: revCount " + revCount);
					}
					//ResultSet result2 = c.evalSt.executeQuery();
					//int evalCount = this.getCount(result2);
					double evalCount = c.getFullyGroundSize() - revCount;
					if (evalCount < 0) {
						throw new RuntimeException(
							"Integer overflow: revCount " + revCount
								+ ", ground size: " + c.getFullyGroundSize());
					}
					if (c.isPositiveClause()) {
						clauseViolationMap.put(c.getStrId(),
							new Pair<Double, Double>(revCount, evalCount));
					} else {
						clauseViolationMap.put(c.getStrId(),
							new Pair<Double, Double>(evalCount, revCount));
					}
				}
			}
		} catch (SQLException e) {
			throw new RuntimeException(e);
		}
		if (Config.verbose_level >= 1) {
			Timer.printElapsed(countTimer);
		}
		return clauseViolationMap;
	}
	
	public double countTotalGroundings( ) {
		double count = 0;
		for (Clause c : this.mln.getAllNormalizedClauses()) {
			count += c.getFullyGroundSize();
		}
		return count;
	}

}
